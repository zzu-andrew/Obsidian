

## 命名空间


命名空间是Linux操作系统内核的一种资源隔离方式，使不同的进程具有不同的系统视图。系统视图就是进程能够感知到的系统环境，如主机名、文件系统、网络协议栈、其他用户和进程等。使用命名空间后，每个进程都具备独立的系统环境，进程间彼此感觉不到对方的存在，进程之间相互隔离。Linux中的命名空间共有6种，可以嵌套使用。

- `Mount` : 隔离了文件系统挂载点，处于不同 `mount` 命名空间的进程可以查看不同的文件系统
- `Network` : 隔离进程网络方面的系统资源
- `IPC` : 进程间相互通讯的命名空间，不同命名空间中的进程不能通信
- `PID` : 不同命名空间中的进程号可以相同，但是进程在操作系统中的全局(命名空间外)的编号唯一的。
- `UTS` : 系统标识符命名空间，在每个命名空间中都可以有不同的主机名和 `NIS` 域名
- `User` : 命名空间中的用户可以有不同于全局的用户ID和组ID，从而具有不同的特权。

命名空间实现了在同一操作系统中隔离进程的方法，几乎没有额外的系统开销，所以是非常轻量的隔离方式，进程启动和运行的过程在命名空间中和外面几乎没有差别。


命名空间属于Kubernetes集群范畴的资源对象， 在一个集群里可以创建多个命名空间， 每个命名空间都是相互独立的存在， 属于不同命名空间的资源对象从逻辑上相互隔离。 在每个Kubernetes集群安装完成且正常运行之后， Master会自动创建两个命名空间， 一个是默认的（default） 、 一个是系统级的（kube-system） 。 用户创建的资源对象如果没有指定命名空间， 则被默认存放在default命名空间中； 而系统相关的资源对象如网络组件、 DNS组件、 监控类组件等， 都被安装在kube-system命名空间中。 我们可以通过命名空间将集群内部的资源对象“分配”到不同的命名空间中， 形成逻辑上分组的不同项目、 小组或用户组， 便于不同的分组在共享使用整个集群的资源的同时能被分别管理。 当给每个租户都创建一个命名空间来实现多租户的资源隔离时， 还能结合Kubernetes的资源配额管理， **限定不同租户能占用的资源**


## 控制组

命名空间实现了进程隔离功能，这些隔离功能是用户层面的，但是各个命名空间中的进程还是共享同样的系统资源，`CPU`、`磁盘I/O`、内存等。所以如果某个进程长时间占用某些资源，其他命名空间里的进程就会受到影响，这就是“吵闹的邻居（`noisy neighbors`）”现象。因此，命名空间并没有完全达到进程隔离的目的。为此，Linux内核提供了控制组（`Control Groups`，`cgroups`）功能来处理这个问题。
`Linux`把进程分成控制组，给每组里的进程都设定资源使用规则和限制。在发生资源竞争时，系统会根据每个组的定义，按照比例在控制组之间分配资源。控制组可设定规则的资源包括`CPU`、内存、磁盘`I/O`和网络等。通过这种方式，就不会出现某些进程无限度抢占其他进程资源的情况。
Linux系统通过命名空间设置进程的可见且可用资源，通过控制组规定进程对资源的使用量，这样隔离进程的虚拟环境（即容器）就建立起来了。



## 容器

### 容器运行时

`Linux` 提供了命名空间和控制组两大系统功能，它们是容器的基础。但是，要把进程运行在容器中，还需要有便捷的`SDK`或命令来调用`Linux`的系统功能，从而创建出容器。容器的运行时（`runtime`）就是容器进程运行和管理的工具。
容器运行时分为低层运行时和高层运行时，功能各有侧重。低层运行时主要负责运行容器，可在给定的容器文件系统上运行容器的进程；高层运行时则主要为容器准备必要的运行环境，如容器镜像下载和解压并转化为容器所需的文件系统、创建容器的网络等，然后调用低层运行时启动容器。

![](attachments/Pasted%20image%2020250205111925.png)



### `CRI` 和 `CRI-O`


![](attachments/Pasted%20image%2020250205113558.png)



本地计算机上容器生命周期变化


![](attachments/Pasted%20image%2020250205145811.png)







## 环境变量

在 `kubernetes` 中，会将 `Service` 对象以环境变量的形式注入到新生成的Pod中，其他Pod中想使用直接按照命名规则传递环境变量即可。

*环境变量的命名规则*

`Kubernetes` 为每个 Service 生成一组环境变量，命名规则如下：
1. **Service 名称转换为大写**，并将 `-` 替换为 `_`。
2. **前缀**：
   - `{SVCNAME}_SERVICE_HOST`：Service 的 `ClusterIP` 或 `DNS` 名称。
   - `{SVCNAME}_SERVICE_PORT`：Service 的端口号。
   - `{SVCNAME}_SERVICE_PORT_{PORTNAME}`：如果 Service 定义了多个端口，每个端口会生成一个单独的环境变量。

假设有一个名为 `redis` 的 Service，它暴露了端口 `6379`，那么在新生成的 Pod 中，你可以通过以下环境变量访问该 Service：

```bash
REDIS_SERVICE_HOST=10.96.123.45
REDIS_SERVICE_PORT=6379
```

1. **Service 必须在 Pod 创建之前存在**：
   - Kubernetes 只在 Pod 创建时注入环境变量。如果 Service 在 Pod 创建之后才创建，那么这些环境变量不会自动更新到已存在的 Pod 中。

2. **`DNS` 是更推荐的方式**：
   - 虽然环境变量是一种简单的服务发现机制，但 `Kubernetes` 更推荐使用 `DNS` 来解析 `Service`。每个 Service 都会自动分配一个 `DNS` 名称，格式为：`<service-name>.<namespace>.svc.cluster.local`。
   - 例如，`redis.default.svc.cluster.local` 可以直接解析到 `redis` Service 的 `ClusterIP`。

3. **环境变量可能过多**：
   - 如果集群中有大量 Service，环境变量可能会变得非常多，这可能会导致 Pod 的环境变量列表过长。因此，DNS 是更灵活和可扩展的解决方案。

你可以通过以下命令查看 Pod 中的环境变量：
```bash
kubectl exec <pod-name> -- env
```

### 总结
Kubernetes 通过环境变量提供了一种简单的服务发现机制，但更推荐使用 DNS 来解析 Service。环境变量适用于简单的场景，而 DNS 更适合大规模和动态的环境。