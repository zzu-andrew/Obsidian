


使用原生库来连接到ssh服务器

```go
package main  
  
import (  
    "fmt"  
    "golang.org/x/crypto/ssh"    "log")  
  
func main() {  
  
    // 配置 SSH 客户端  
    config := &ssh.ClientConfig{  
       User: "root",  
       Auth: []ssh.AuthMethod{  
          ssh.Password("Bingo@1993"),  
       },  
       HostKeyCallback: ssh.InsecureIgnoreHostKey(), // 注意：这会忽略主机密钥验证，生产环境中应使用更安全的方式  
    }  
  
    // 连接到远程服务器  
    conn, err := ssh.Dial("tcp", "10.161.40.240:22", config)  
    if err != nil {  
       log.Fatalf("Failed to dial: %v", err)  
    }  
    defer conn.Close()  
  
    // 创建一个新的会话  
    session, err := conn.NewSession()  
    if err != nil {  
       log.Fatalf("Failed to create session: %v", err)  
    }  
    defer session.Close()  
  
    // 执行远程命令  
    output, err := session.CombinedOutput("uname -a")  
    if err != nil {  
       log.Fatalf("Failed to run: %v", err)  
    }  
  
    fmt.Println(string(output))  
}
```


上传本地文件

```go
package main  
  
import (  
    "fmt"  
    "io"    "io/ioutil"    "log"    "os"  
    "github.com/pkg/sftp"    "golang.org/x/crypto/ssh")  
  
func main() {  
    // 读取私钥文件  
    privateKey, err := ioutil.ReadFile("/path/to/private_key")  
    if err != nil {  
       log.Fatalf("Unable to read private key: %v", err)  
    }  
  
    // 解析私钥  
    signer, err := ssh.ParsePrivateKey(privateKey)  
    if err != nil {  
       log.Fatalf("Unable to parse private key: %v", err)  
    }  
  
    // 配置 SSH 客户端  
    config := &ssh.ClientConfig{  
       User: "your_username",  
       Auth: []ssh.AuthMethod{  
          ssh.PublicKeys(signer),  
       },  
       HostKeyCallback: ssh.InsecureIgnoreHostKey(),  
    }  
  
    // 连接到远程服务器  
    conn, err := ssh.Dial("tcp", "your_server_ip:22", config)  
    if err != nil {  
       log.Fatalf("Failed to dial: %v", err)  
    }  
    defer conn.Close()  
  
    // 创建 SFTP 客户端  
    sftpClient, err := sftp.NewClient(conn)  
    if err != nil {  
       log.Fatalf("Failed to create SFTP client: %v", err)  
    }  
    defer sftpClient.Close()  
  
    // 上传文件  
    localFile, err := os.Open("/path/to/local/file")  
    if err != nil {  
       log.Fatalf("Failed to open local file: %v", err)  
    }  
    defer localFile.Close()  
  
    remoteFile, err := sftpClient.Create("/path/to/remote/file")  
    if err != nil {  
       log.Fatalf("Failed to create remote file: %v", err)  
    }  
    defer remoteFile.Close()  
  
    _, err = io.Copy(remoteFile, localFile)  
    if err != nil {  
       log.Fatalf("Failed to upload file: %v", err)  
    }  
  
    fmt.Println("File uploaded successfully!")  
}
```




Excalidraw中支持将文本数据直接黏贴成图表，例如：

```bash
Day,Commits
Mon,167 
Tue,92 
Wed,114
Thu,195
Fri,155
Sat,97
Sun,42
```


```go
package main  
  
import (  
    "bufio"  
    "bytes"    "fmt"    "os/exec")  
  
func main() {  
    // 创建命令  
    cmd := exec.Command("bash", "-c", "read -p '请输入你的名字: ' name; echo '你好, '$name")  
  
    // 创建一个新的缓冲区用于存储命令的输出  
    var out bytes.Buffer  
  
    // 设置命令的标准输出和标准错误到我们的缓冲区  
    cmd.Stdout = &out  
    cmd.Stderr = &out  
  
    // 运行命令但是不等待它完成，因为我们还需要向它的标准输入写入数据  
    stdin, err := cmd.StdinPipe()  
    if err != nil {  
       fmt.Println("无法获取标准输入管道:", err)  
       return  
    }  
  
    // 开始执行命令  
    if err := cmd.Start(); err != nil {  
       fmt.Println("命令执行失败:", err)  
       return  
    }  
  
    // 向命令的标准输入写入数据  
    _, err = stdin.Write([]byte("张三\n"))  
    if err != nil {  
       fmt.Println("写入标准输入时出错:", err)  
       return  
    }  
  
    // 关闭标准输入，表示我们完成了输入  
    if err := stdin.Close(); err != nil {  
       fmt.Println("关闭标准输入时出错:", err)  
       return  
    }  
  
    // 等待命令执行完成  
    if err := cmd.Wait(); err != nil {  
       fmt.Println("命令执行过程中出错:", err)  
    }  
  
    // 打印命令的输出结果  
    fmt.Println("命令输出:")  
    scanner := bufio.NewScanner(&out)  
    for scanner.Scan() {  
       fmt.Println(scanner.Text())  
    }  
}
